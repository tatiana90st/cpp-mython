# Интерпретатор языка Mython (упрощенного подмножества Python)  
На вход поступает текст программы, а интерпретатор выводит в выходной поток результат всех команд print  
Интерпретатор состоит из четырёх основных логических блоков:
- Лексический анализатор, или лексер  
- Синтаксический анализатор, или парсер  
- Семантический анализатор  
- Таблица символов  
## Лексический анализатор
Лексический анализатор — его также называют сканером или лексером — считывает последовательность символов, которые составляют исходную программу, и формирует из них значащие последовательности символов — лексемы. Для каждой лексемы анализатор строит выходной токен.
1. [lexer.h](https://github.com/tatiana90st/cpp-mython/blob/main/mython/lexer.h)
2. [lexer.cpp](https://github.com/tatiana90st/cpp-mython/blob/main/mython/lexer.cpp)  
3. [unit tests](https://github.com/tatiana90st/cpp-mython/blob/main/mython/lexer_test_open.cpp) 
#### Тип Token 
Для удобства представления лексем используется std::variant
##### Методы для компактного анализа содержимого токенов:
- bool Is()  
- const T& As()  
- const T* TryAs()  
#### Класс Lexer 
Выполняет лексический разбор программы. Класс принимает ссылку на поток ввода, из которого считывает текст программы, и выдаёт последовательность лексем программы.   
##### Методы:  
- **const Token& CurrentToken()** возвращает ссылку на последнюю лексему, считанную лексером. Этот метод можно вызывать у объекта сразу после его создания. После выполнения метода NextToken метод CurrentToken должен возвращает ссылку на только что считанную лексему
- **Token NextToken()** считывает и возвращает очередную лексему из входного потока. Если входной поток пуст, метод возвращает лексему token_type::Eof  
- **Expect<T>()** проверяет, что CurrentToken() имеет тип T. Если это не так, он бросает исключение LexerError  
- **Expect<T, U>(const U& value)** проверяет, что CurrentToken() имеет тип T, а значение текущей лексемы равно value  
- **ExpectNext<T>() и ExpectNext<T, U>(const U& value)** сначала вызывают NextToken, а затем — соответствующий метод Expect
## Runtime-модуль интерпретатора
Отвечает за управление состоянием программы во время её работы. Модуль реализует встроенные типы данных языка Mython и таблицу символов
1. [runtime.h](https://github.com/tatiana90st/cpp-mython/blob/main/mython/runtime.h)
2. [runtime.cpp](https://github.com/tatiana90st/cpp-mython/blob/main/mython/runtime.cpp)  
3. [unit tests](https://github.com/tatiana90st/cpp-mython/blob/main/mython/runtime_test.cpp)   

#### Абстрактный класс Object
Его единственный чисто виртуальный метод Print выводит строковое представление объекта в заданный поток вывода. Наследники Object, отвечающие за хранение конкретных типов объектов, переопределят этот метод в соответствии с требованиями языка  
**Классы-наследники Object:**  
- Шаблонный класс ValueObject<T> — основа для представления объектов-значений: строк, чисел и логических значений. Параметр T задаёт тип для хранения значений - int, std::string или bool. На основе шаблона ValueObject определены классы String, Bool и Number  
- Class хранит информацию о пользовательском классе: набор собственных методов класса и ссылку на класс-родитель. Метод класса — это исполняемый фрагмент кода на Mython, у которого есть имя и набор формальных параметров. В интерпретаторе метод представлен структурой Method  
- ClassInstance — экземпляр класса, хранит значения полей. Предоставляет доступ к полям объекта и позволяет вызывать его методы
#### Класс ObjectHolder
Вспомогательный класс-обёртка. Содержит методы, которые облегчают конструирование объектов и доступ к их значению  
**Методы:**
- Own<T> копирует или перемещает значение конкретного класса-наследника Object в динамическую память и возвращает владеющий этим объектом ObjectHolder. Копии возвращённого ObjectHolder будут также совместно владеть объектом. Это основной способ создания ObjectHolder  
- Share возвращает невладеющий ObjectHolder, который ссылается на существующий объект, но не контролирует время жизни. Такой способ создания ObjectHolder применяется для передачи self при вызове методов  
- None возвращает «пустой» ObjectHolder, эквивалентный значению None  
#### Интерфейс Executable
Связывает runtime-модуль с семантическим анализатором
#### Интерфейс Context  
Используется методом Object::Print. Этот интерфейс обеспечивает связь интерпретатора с внешним миром. Метод Context::GetOutputStream() возвращает ссылку на поток вывода, в который интерпретатор выводит данные, встретив команду print
#### Дополнительные функции  
- Функция bool IsTrue(const ObjectHolder& object) проверяет, содержится ли в object значение, приводимое к True. Для значений 0, False, None и пустых строк функция возвращает false. В остальных случаях возвращается true
- Функция Equal возвращает true, если её аргументы содержат одинаковые числа, строки или логические значения, и false — если разные  
- Функция Less для объектов, которые хранят строки, числа и логические значения, возвращает результат сравнения, используя оператор <  
- Функции NotEqual, Greater, LessOrEqual, GreaterOrEqual реализуются на основе Equal и/или Less
## Классы-узлы абстрактного синтаксического дерева (AST)
1. [statement.h](https://github.com/tatiana90st/cpp-mython/blob/main/mython/statement.h)
2. [statement.cpp](https://github.com/tatiana90st/cpp-mython/blob/main/mython/statement.cpp)  
3. [unit tests](https://github.com/tatiana90st/cpp-mython/blob/main/mython/statement_test.cpp) 
